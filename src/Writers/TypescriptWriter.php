<?php

declare(strict_types=1);

namespace Frolax\Typescript\Writers;

use Frolax\Typescript\Contracts\WriterContract;
use Frolax\Typescript\Data\EnumDefinition;
use Frolax\Typescript\Data\GenerationResult;
use Frolax\Typescript\Data\ModelGenerationResult;
use Frolax\Typescript\Data\WriterConfig;
use Frolax\Typescript\Support\CaseFormatter;

/**
 * Default TypeScript interface/type writer.
 */
class TypescriptWriter implements WriterContract
{
    public function __construct(
        private readonly CaseFormatter $caseFormatter = new CaseFormatter,
    ) {}

    public function name(): string
    {
        return 'interface';
    }

    public function write(GenerationResult $result, WriterConfig $config): WriterOutput
    {
        $keyword = $config->writer === 'type' ? 'type' : 'interface';
        $header = "// This file is auto-generated by laravel-typescript.\n// Do not edit this file manually.\n";

        // Per-model file mode
        if ($config->perModelFiles) {
            return $this->writePerModelFiles($result, $config, $keyword, $header);
        }

        // Single-file mode (default)
        $lines = [];
        $lines[] = '// This file is auto-generated by laravel-typescript.';
        $lines[] = '// Do not edit this file manually.';
        $lines[] = '';

        foreach ($result->models as $modelResult) {
            $lines = array_merge($lines, $this->writeModelDefinition($modelResult, $config, $keyword));
            $lines[] = '';

            if ($config->fillableTypes && ! empty($modelResult->fillable)) {
                $lines = array_merge($lines, $this->writeFillableType($modelResult, $config, $keyword));
                $lines[] = '';
            }
        }

        foreach ($result->enums as $enum) {
            $lines = array_merge($lines, $this->writeEnum($enum, $config));
            $lines[] = '';
        }

        foreach ($result->standaloneTypes as $name => $definition) {
            $lines = array_merge($lines, $this->writeStandaloneType($name, $definition, $config));
            $lines[] = '';
        }

        $content = implode("\n", $lines);

        if ($config->globalNamespace !== null) {
            $content = $this->wrapInNamespace($content, $config->globalNamespace);
        }

        return new WriterOutput(
            stdout: $content,
            files: [$config->singleFileName ?? 'models.d.ts' => $content],
        );
    }

    /**
     * Generate per-model files with individual model/enum files and barrel export.
     */
    private function writePerModelFiles(
        GenerationResult $result,
        WriterConfig $config,
        string $keyword,
        string $header,
    ): WriterOutput {
        $files = [];
        $exports = [];

        // Write individual model files
        foreach ($result->models as $modelResult) {
            $lines = [$header];
            $lines = array_merge($lines, $this->writeModelDefinition($modelResult, $config, $keyword));

            if ($config->fillableTypes && ! empty($modelResult->fillable)) {
                $lines[] = '';
                $lines = array_merge($lines, $this->writeFillableType($modelResult, $config, $keyword));
            }

            $fileName = $modelResult->shortName.'.ts';
            $files[$fileName] = implode("\n", $lines)."\n";
            $exports[] = "export * from './{$modelResult->shortName}';";
        }

        // Write individual enum files
        $enumDir = $config->enumDirectory ?? 'enums';
        foreach ($result->enums as $enum) {
            $lines = [$header];
            $lines = array_merge($lines, $this->writeEnum($enum, $config));

            $fileName = "{$enumDir}/{$enum->shortName}.ts";
            $files[$fileName] = implode("\n", $lines)."\n";
            $exports[] = "export * from './{$enumDir}/{$enum->shortName}';";
        }

        // Write barrel export (index.ts)
        if ($config->barrelExport) {
            // Write common types file if any
            if (! empty($result->standaloneTypes)) {
                $lines = [$header];
                foreach ($result->standaloneTypes as $name => $definition) {
                    $lines = array_merge($lines, $this->writeStandaloneType($name, $definition, $config));
                    $lines[] = '';
                }
                $files['types.ts'] = implode("\n", $lines);
                $exports[] = "export * from './types';";
            }

            sort($exports);
            $indexContent = $header.implode("\n", $exports)."\n";
            $files['index.ts'] = $indexContent;
        }

        $stdout = implode("\n\n", array_values($files));

        return new WriterOutput(
            stdout: $stdout,
            files: $files,
        );
    }

    /**
     * Write a single model interface/type definition.
     *
     * @return list<string>
     */
    private function writeModelDefinition(
        ModelGenerationResult $model,
        WriterConfig $config,
        string $keyword,
    ): array {
        $indent = $config->indent;
        $typeName = $this->caseFormatter->formatTypeName($model->shortName, $config->plurals);
        $lines = [];

        if ($keyword === 'type') {
            $lines[] = "export {$keyword} {$typeName} = {";
        } else {
            $lines[] = "export {$keyword} {$typeName} {";
        }

        // Columns section
        $columnProps = $model->properties->where('section', 'columns');
        if ($columnProps->isNotEmpty()) {
            foreach ($columnProps as $prop) {
                $name = $this->caseFormatter->formatProperty($prop['name'], $config->columnCase);
                $optional = $prop['optional'] ? '?' : '';
                $lines[] = "{$indent}{$name}{$optional}: {$prop['tsType']};";
            }
        }

        // Mutators/Accessors section
        $mutatorProps = $model->properties->where('section', 'mutators');
        if ($mutatorProps->isNotEmpty()) {
            $lines[] = "{$indent}// Accessors";
            foreach ($mutatorProps as $prop) {
                $name = $this->caseFormatter->formatProperty($prop['name'], $config->columnCase);
                $optional = $prop['optional'] ? '?' : '';
                $lines[] = "{$indent}{$name}{$optional}: {$prop['tsType']};";
            }
        }

        // Relations
        if ($model->relations->isNotEmpty()) {
            $lines[] = "{$indent}// Relations";
            foreach ($model->relations as $relation) {
                $name = $this->caseFormatter->formatProperty($relation->name, $config->relationCase);
                $optional = ($config->writer !== 'type' && ($relation->optional || $this->isRelationOptional($config))) ? '?' : '';
                $lines[] = "{$indent}{$name}{$optional}: {$relation->tsType};";
            }
        }

        // Counts
        if ($model->counts->isNotEmpty()) {
            $lines[] = "{$indent}// Counts";
            foreach ($model->counts as $count) {
                $name = $this->caseFormatter->formatProperty($count->name, $config->columnCase);
                $optional = $count->optional ? '?' : '';
                $lines[] = "{$indent}{$name}{$optional}: {$count->tsType};";
            }
        }

        // Exists
        if ($model->exists->isNotEmpty()) {
            $lines[] = "{$indent}// Exists";
            foreach ($model->exists as $exist) {
                $name = $this->caseFormatter->formatProperty($exist->name, $config->columnCase);
                $optional = $exist->optional ? '?' : '';
                $lines[] = "{$indent}{$name}{$optional}: {$exist->tsType};";
            }
        }

        // Sums
        if ($model->sums->isNotEmpty()) {
            $lines[] = "{$indent}// Sums";
            foreach ($model->sums as $sum) {
                $name = $this->caseFormatter->formatProperty($sum->name, $config->columnCase);
                $optional = $sum->optional ? '?' : '';
                $lines[] = "{$indent}{$name}{$optional}: {$sum->tsType};";
            }
        }

        if ($keyword === 'type') {
            $lines[] = '};';
        } else {
            $lines[] = '}';
        }

        return $lines;
    }

    /**
     * Write a fillable type (subset of model properties).
     *
     * @return list<string>
     */
    private function writeFillableType(
        ModelGenerationResult $model,
        WriterConfig $config,
        string $keyword,
    ): array {
        $indent = $config->indent;
        $typeName = $model->shortName.$config->fillableSuffix;
        $lines = [];

        if ($keyword === 'type') {
            $lines[] = "export {$keyword} {$typeName} = {";
        } else {
            $lines[] = "export {$keyword} {$typeName} {";
        }

        $fillableNames = $model->fillable;
        foreach ($model->properties as $prop) {
            if (in_array($prop['name'], $fillableNames)) {
                $name = $this->caseFormatter->formatProperty($prop['name'], $config->columnCase);
                $lines[] = "{$indent}{$name}: {$prop['tsType']};";
            }
        }

        if ($keyword === 'type') {
            $lines[] = '};';
        } else {
            $lines[] = '}';
        }

        return $lines;
    }

    /**
     * Write an enum definition.
     *
     * @return list<string>
     */
    private function writeEnum(EnumDefinition $enum, WriterConfig $config): array
    {
        $indent = $config->indent;
        $lines = [];

        match ($config->enumStyle) {
            'ts_enum' => $this->writeEnumAsTypeScriptEnum($enum, $indent, $lines),
            'union' => $this->writeEnumAsUnion($enum, $lines),
            default => $this->writeEnumAsConstObject($enum, $indent, $lines),
        };

        return $lines;
    }

    private function writeEnumAsConstObject(EnumDefinition $enum, string $indent, array &$lines): void
    {
        $lines[] = "export const {$enum->shortName} = {";

        foreach ($enum->cases as $name => $value) {
            $formattedValue = is_string($value) ? "'{$value}'" : $value;
            $lines[] = "{$indent}{$name}: {$formattedValue},";
        }

        $lines[] = '} as const;';
        $lines[] = '';
        $lines[] = "export type {$enum->shortName} = typeof {$enum->shortName}[keyof typeof {$enum->shortName}];";
    }

    private function writeEnumAsTypeScriptEnum(EnumDefinition $enum, string $indent, array &$lines): void
    {
        $lines[] = "export enum {$enum->shortName} {";

        foreach ($enum->cases as $name => $value) {
            $formattedValue = is_string($value) ? "'{$value}'" : $value;
            $lines[] = "{$indent}{$name} = {$formattedValue},";
        }

        $lines[] = '}';
    }

    private function writeEnumAsUnion(EnumDefinition $enum, array &$lines): void
    {
        $values = array_map(
            fn ($value) => is_string($value) ? "'{$value}'" : (string) $value,
            $enum->cases
        );

        $lines[] = "export type {$enum->shortName} = ".implode(' | ', $values).';';
    }

    /**
     * Wrap content in a declare global namespace.
     */
    private function wrapInNamespace(string $content, string $namespace): string
    {
        $indentedContent = implode(
            "\n",
            array_map(
                fn (string $line) => $line !== '' ? "  {$line}" : '',
                explode("\n", $content)
            )
        );

        return <<<TS
        declare namespace {$namespace} {
        {$indentedContent}
        }
        TS;
    }

    /**
     * Write a standalone custom type/interface.
     *
     * @return list<string>
     */
    private function writeStandaloneType(string $name, string $definition, WriterConfig $config): array
    {
        $lines = [];
        $definition = trim($definition);

        // If the definition doesn't start with 'interface' or 'type', wrap it
        if (! str_starts_with($definition, 'interface') && ! str_starts_with($definition, 'type')) {
            if (str_starts_with($definition, '{')) {
                $lines[] = "export interface {$name} {$definition}";
            } else {
                $lines[] = "export type {$name} = {$definition};";
            }
        } else {
            // Ensure it's exported
            if (! str_starts_with($definition, 'export')) {
                $definition = "export {$definition}";
            }
            $lines[] = $definition;
        }

        return $lines;
    }

    private function isRelationOptional(WriterConfig $config): bool
    {
        // Check if the writer config has optional relations
        return false; // Default, overridden by config
    }
}
